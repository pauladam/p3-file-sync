
Django provides a suitable web framework for accomplishing common tasks (MVC architecture, an ORM, templating etc) yet it still provides raw access to HTTP primitives (request.META aka env vars), headers etc so that when Django is lacking or makes assumptions about how something should work, if you have the know-how you can access the primitives directly.

Django's tight integration with its internal ORM makes persisting data an extremely straightforward affair. Defining DB tables (Django models) is done with a very simple method of subclassing a model object specifying it to your application by adding the fields you require. The ORM api for dealing w/ these objects is very lightweight and simple as well which makes acquisition easy. The benefit is that once youve defined these models it makes it easy to start working with these tables as pure python objects. For this application no custom sql was needed to serve its needs.

Django's built in admin tools make setting up administration trivially easy. By changing a few basic settings, Django interprets youre data model and generates the needed logic to handle basic CRUD tasks associated with your model so without writing any project specific code once youve defined your data models you can start interacting with them very easily in 2 ways, either through the autogenerated admin interface which exposes basic CRUD tasks or via the django python shell. Its quite useful, for example, to use these tools to generate data objects so that you can quickly get to writing code that manipulates them directly without needing to perform all the upfront data creation / loading code code writing tasks first.

Django's built in webserver serves the same function as the restlets webserver but since Python is interpreted Django can simply re-load the source every time it detects an update to the source. This makes development much faster as it removes not only the compile cycle but the server restart step as well. In practice this means that the edit cycle, for many practical cases, is distilled down to a source edit followed by a browser refresh.

Java support for asynchronous tasks such as threading is definitely much more thought out. Django doesnt really support or encourage asynchronous tasks (such as watching the filesystem), instead most of the work is done via one-off cron jobs as far as I can tell. Though there are some new, young frameworks / approaches in Django for creating 'jobs' and the like, its still fairly new territory and not nearly as mature as whats available from the JDK.

Along the same lines, Django is very much a request driven-response model where django expects work to happen at request time. Certainly larger sites add their own patches or libraries to deal with off-request time job processing but its not encouraged by Django out of the box. My stop gap solution was to have Django run my own python module which started up a few threads to do interval based tasks such as file system walking, heartbeat pinging, server change notifications etc etc. This solution works but its not really attractive. 

Python triple quoted strings plus the built in string formatting operator make building XML very easy, we can then parse this into an xml tree to ensure that its well-formed.

  # Create raw, schema-less xml
  xml_in = """<Settings>
                 <Root directory="%s"/>
               </Settings>"""

  # Interpolate in the root directory 
  xml_in = xml_out % root_dir

  # Parse string into a proper xml tree
  xml_out = elementtree.ElementTree.fromstring(xml_out)

  return HttpResponse(elementtree.ElementTree.tostring(xml_out), mimetype="text/xml")


